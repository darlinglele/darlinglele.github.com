<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>Home</title>
 <link href="http://username.github.com/atom.xml" rel="self"/>
 <link href="http://username.github.com"/>
 <updated>2012-04-28T22:13:51+08:00</updated>
 <id>http://username.github.com</id>
 <author>
   <name>Lin Zhixiong</name>
   <email>darlinglele@gmail.com</email>
 </author>

 
 <entry>
   <title>Clean code notes</title>
   <link href="http://username.github.com/2012/04/27/clean-code-notes"/>
   <updated>2012-04-27T00:00:00+08:00</updated>
   <id>http://username.github.com/2012/04/27/clean-code-notes</id>
   <content type="html">&lt;p&gt;&lt;strong&gt;处理Try/Catch&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Try/Catch 代码块经常破坏了代码的结构，把正常错里和错误处理混为一谈。因此应当把错误处理单独处理，放在一个单独的方法里，并却这个方法仅仅做错误处理一件事情。在这样的方法里try应当是第一个单词，并且catch/finaly 后面也不该有其他的内容。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public void delete(){
	 try{
		deletePage();
	 }
	 catch{
		logError();
	 }

 } 

public void deletePage(){
	 .....  ..... 
 }&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面例子中delete只做与错误处理相关的事情，忽略了deletePage的逻辑。 deletePage也只处理删除页面的逻辑，忽略了错误处理相关的事情。这样美妙的隔离更容易理解和修改。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;数据和对象的反对称性&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;数据结构向外部暴露起数据，而不提供有意义的函数，对象则相反，对象把数据隐藏在抽象之后，暴露操作数据的函数。&lt;/p&gt;

&lt;p&gt;过程式代码（使用数据结构的代码）便于在不改变数据结构的前提下添加新函数。面向对象代码便于在不改变既有函数的前提下添加新类&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>hello world</title>
   <link href="http://username.github.com/2012/04/05/hello-world"/>
   <updated>2012-04-05T00:00:00+08:00</updated>
   <id>http://username.github.com/2012/04/05/hello-world</id>
   <content type="html">&lt;p&gt;This is the first blog using markdown file!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;What is markdown ?&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The markdown is descripted on &lt;a href='http://en.wikipedia.org/wiki/markdown'&gt;wikipedia&lt;/a&gt; as this.&lt;/p&gt;</content>
 </entry>
 
 
</feed>